/*
 * Copyright 2019 Suslennikov Anton
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Method executes any command with respect of environment variables and work directory
 * @param executionCommand what to execute
 * @param environmentVariables specifies environment
 * @param workDirectory where to execute
 *
 * @return {@code executionCommand} result status, {@code true} if it was successfully executed
 */
private static boolean executeCommand(String executionCommand, List<String> environmentVariables, File workDirectory) {
    // Uncomment only for debugging! Sensitive data can be leaked to logs!
    // println "Executing: [${executionCommand}]"
    def process = executionCommand.execute(environmentVariables, workDirectory)
    def processOut = new StringBuffer()
    def processErr = new StringBuffer()
    process.consumeProcessOutput(processOut, processErr)
    process.waitForOrKill(5 * 1000) // 5 sec
    /*
    // Uncomment only for debugging! Sensitive data can be leaked to logs!
    if (processOut.size() > 0) {
        println processOut
    } else if (processErr.size() > 0) {
        println processErr
    }
    */
    return process.exitValue() == 0
}

/**
 * @return environment variables for commands (such as 'git checkout', 'git commit' and etc)
 */
private static List<String> executeCommandEnvironment() {
    return [
            'GIT_COMMITTER_NAME="Release Machine"',
            'GIT_COMMITTER_EMAIL="anton.external@gmail.com"',
            'GIT_AUTHOR_NAME="Release Machine"',
            'GIT_AUTHOR_EMAIL="anton.external@gmail.com"'
    ]
}

/**
 * @return Provides a command string to add github project as a remote for current repository
 */
private String addOriginCommand() {
    return "git remote add https_origin https://asuslennikov:${githubKey}@github.com/asuslennikov/mvvm.git"
}

/**
 * @return Provides a command string to remove github project url from list of remotes
 */
private String removeOriginCommand() {
    return "git remote rm https_origin"
}

/**
 * This method prepares repository for the next release. It will:
 * <ul>
 *     <li> create a new branch with name 'release_$vMajor_$vMinor_$vPatch', for example 'release_0_8_30' </li>
 *     <li> update the properties file 'release/release.properties' with given version </li>
 *     <li> update the 'CHANGELOG.md' file with given version </li>
 *     <li> add these changes to git index, commit and push to remote repository
 *     (see {@link #addOriginCommand()}). </li>
 * </ul>
 *
 * @param vMajor major version's part for the next release
 * @param vMinor minor version's part for the next release
 * @param vPatch patch version's part for the next release
 */
private void createNextRelease(vMajor, vMinor, vPatch) {
    def environment = executeCommandEnvironment()
    def workDirectory = rootProject.projectDir
    def releasePropertiesFile = new File(workDirectory, 'release/release.properties')
    releasePropertiesFile.write(
            """release.version.major=${vMajor}
release.version.minor=${vMinor}
release.version.patch=${vPatch}"""
    )
    def changelogFile = new File(workDirectory, 'CHANGELOG.md')
    def currentChangelog = changelogFile.readBytes()
    changelogFile.write("# v${vMajor}.${vMinor}.${vPatch}\n\n\n" + new String(currentChangelog, "UTF-8"))
    def releaseBranchName = "release_${vMajor}_${vMinor}_${vPatch}"
    boolean result = false
    try {
        result = executeCommand("git checkout -b ${releaseBranchName}", environment, workDirectory) &&
                executeCommand("git add ${releasePropertiesFile.absolutePath} ${changelogFile.absolutePath}", environment, workDirectory) &&
                executeCommand("git commit -m \"Prepare release v${vMajor}.${vMinor}.${vPatch}\"", environment, workDirectory) &&
                executeCommand(addOriginCommand(), environment, workDirectory) &&
                executeCommand("git push --set-upstream https_origin ${releaseBranchName}", environment, workDirectory)
    } catch (Exception ex) {
        println(ex)
    } finally {
        // always remove origin, even if push fails
        executeCommand(removeOriginCommand(), environment, workDirectory)
    }
    if (!result) {
        throw new RuntimeException("Can't create a new release. Try to uncomment the 'executeCommand' debug code.")
    }
}

task applyReleaseTag() {
    group = "Repository"
    description = "Marks the current commit with release tag and push it to server"
    doLast {
        List<String> environment = executeCommandEnvironment()
        def workDirectory = rootProject.projectDir
        boolean result = false
        try {
            def tagCommand = "git tag -am \"Release $versionTag\" $versionTag"
            result = executeCommand(tagCommand, environment, workDirectory) &&
                    executeCommand(addOriginCommand(), environment, workDirectory) &&
                    executeCommand("git push https_origin refs/tags/$versionTag", environment, workDirectory)
        } catch (Exception ex) {
            println(ex)
        } finally {
            // always remove origin, even if push fails
            executeCommand(removeOriginCommand(), environment, workDirectory)
        }
        if (!result) {
            throw new RuntimeException("Can't create a release tag. Try to uncomment the 'executeCommand' debug code.")
        }
    }
}

task createNextMajorRelease() {
    group = "Repository"
    description = "Performs all necessary steps to create the next major release"
    doLast {
        createNextRelease(versionMajor + 1, 0, 0)
    }
}

task createNextMinorRelease() {
    group = "Repository"
    description = "Performs all necessary steps to create the next minor release"
    doLast {
        createNextRelease(versionMajor, versionMinor + 1, 0)
    }
}

task createNextPatchRelease() {
    group = "Repository"
    description = "Performs all necessary steps to create the next patch release"
    doLast {
        createNextRelease(versionMajor, versionMinor, versionPatch / 10 * 10 + 10)
    }
}

task createHotfixRelease() {
    group = "Repository"
    description = "Performs all necessary steps to create a hotfix release"
    doLast {
        createNextRelease(versionMajor, versionMinor, versionPatch + 1)
    }
}