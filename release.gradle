/**
 * Method checks does the project has applied 'android-library' plugin or not.
 * If the plugin was found, this method will return true
 */
static def isAndroidProject(def project) {
    def hasAndroidPlugin = false
    project.plugins.each { plugin ->
        hasAndroidPlugin = hasAndroidPlugin || plugin.class.canonicalName.contains("com.android.build.gradle.LibraryPlugin")
    }
    return hasAndroidPlugin
}

/**
 * Method traverse through nodes in pom and return the 'dependencies', or creates it, if not found.
 */
private static Object getDependenciesNodeFromPom(mavenPom) {
    def dependenciesNode = mavenPom.asNode().dependencies[0]
    if (dependenciesNode == null) {
        dependenciesNode = mavenPom.asNode().appendNode('dependencies')
    }
    return dependenciesNode
}

/**
 * Method replaces sub-module dependencies (like this: 'api project(":mvvm-api")') via
 * correct maven declaration
 */
def fixProjectModuleDependencies(mavenPom) {
    def dependenciesNode = mavenPom.asNode().dependencies[0]
    if (dependenciesNode != null) {
        dependenciesNode.each { dependency ->
            if (dependency.groupId[0].text() == rootProject.name) {
                dependency.groupId[0].setValue("$pomGroupId")
                dependency.version[0].setValue("$currentVersion")
            }
        }
    }
}

/**
 * Method iterates through submodule dependencies and add them to the pom file.
 * Basically should be applied only to android projects, see {@link #isAndroidProject(java.lang.Object)}
 */
def appendDependenciesNodeToPom(def mavenPom, def project, String dependencyType) {
    def dependenciesNode = getDependenciesNodeFromPom(mavenPom)
    project.configurations[dependencyType].allDependencies.each { ModuleDependency dp ->
        if ('unspecified' == dp.version) {
            addDependencyToList(dependenciesNode, pomGroupId, dp.name, currentVersion, dp.excludeRules)
        } else {
            addDependencyToList(dependenciesNode, dp.group, dp.name, dp.version, dp.excludeRules)
        }
    }
}

/**
 * Method adds a specific dependency with given GAV info and correct exclusion handling.
 * @param dependenciesNode node in pom file with all dependencies
 * (see {@link #getDependenciesNodeFromPom(java.lang.Object)})
 * @param group groupId of dependency
 * @param artifact artifactId of dependency
 * @param version version of dependency
 * @param excludeRules exclusions for dependency
 */
private static void addDependencyToList(def dependenciesNode, String group, String artifact, String version, def excludeRules) {
    def dependencyNode = dependenciesNode.appendNode('dependency')
    dependencyNode.appendNode('groupId', group)
    dependencyNode.appendNode('artifactId', artifact)
    dependencyNode.appendNode('version', version)

    if (excludeRules != null && excludeRules.size() > 0) {
        def exclusions = dependencyNode.appendNode('exclusions')
        excludeRules.each { ExcludeRule ex ->
            def exclusion = exclusions.appendNode('exclusion')
            exclusion.appendNode('groupId', ex.group)
            exclusion.appendNode('artifactId', ex.module)
        }
    }
}

/**
 * Method provides access to local-stored private PGP key for signing purposes.
 * We assume that path to that file is stored in environment variable 'SIGN_KEY'.
 * And content of this file must be in base64 encoding.
 */
private static String getSignPrivateKey() {
    def pathInEnvironmentVariables = System.getenv('SIGN_KEY')
    if (pathInEnvironmentVariables == null || pathInEnvironmentVariables.isEmpty()) {
        return ""
    }

    def privateKeyFile = new File(pathInEnvironmentVariables)
    if (!privateKeyFile.exists()) {
        return ""
    }

    return new String(Base64.decoder.decode(new String(privateKeyFile.readBytes(), "UTF-8")))
}

def releaseProperties = new Properties()
file("release.properties").withInputStream { releaseProperties.load(it) }
ext {
    pomGroupId = 'com.github.asuslennikov'
    versionMajor = releaseProperties.getProperty("release.version.major").toInteger()
    versionMinor = releaseProperties.getProperty("release.version.minor").toInteger()
    versionPatch = releaseProperties.getProperty("release.version.patch").toInteger()
    currentVersion = "${versionMajor}.${versionMinor}.${versionPatch}"
    versionTag = "v${currentVersion}"
    bintrayUser = System.getenv('BINTRAY_USER')
    bintrayKey = System.getenv('BINTRAY_KEY')
    ossUser = System.getenv('OSS_USER')
    ossKey = System.getenv('OSS_KEY')
    signPassphrase = System.getenv('SIGN_PASSPHRASE')
    signPrivateKey = getSignPrivateKey()
}
apply plugin: 'io.codearte.nexus-staging'
// apply immediately because bintray need to setup hooks
subprojects {
    apply plugin: 'com.jfrog.bintray'

    bintray {
        user = bintrayUser
        key = bintrayKey
        publications = ['MVVMModule']
        publish = true
        pkg {
            repo = 'maven'
            name = 'android-mvvm'
            userOrg = 'asuslennikov'
            desc = 'Android ViewModel with "clean architecture" and React states.'
            websiteUrl = 'https://github.com/asuslennikov/mvvm'
            issueTrackerUrl = 'https://github.com/asuslennikov/mvvm/issues'
            vcsUrl = 'https://github.com/asuslennikov/mvvm.git'
            licenses = ['Apache-2.0']
            githubRepo = 'asuslennikov/mvvm'
            githubReleaseNotesFile = 'README.md'

            version {
                name = "$currentVersion"
                desc = "Android MVVM library, version $currentVersion"
                released = new Date()
                vcsTag = "$versionTag"

                gpg {
                    sign = false
                }
            }
        }
    }
}
// 'projectsEvaluated' because code based on plugin additions
gradle.projectsEvaluated {
    rootProject.subprojects { childProject ->
        apply plugin: 'maven-publish'
        apply plugin: 'signing'

        task sourcesJar(type: Jar) {
            if (!isAndroidProject(childProject)) {
                from sourceSets.main.allJava
            } else {
                from android.sourceSets.main.java.sourceFiles
            }
            archiveClassifier = 'sources'
        }

        artifacts {
            archives sourcesJar
        }

        publishing {
            publications {
                MVVMModule(MavenPublication) {
                    groupId = "$pomGroupId"
                    artifactId = "$childProject.name"
                    version = "$currentVersion"
                    def isAndroidProject = isAndroidProject(childProject)
                    if (!isAndroidProject) {
                        from components.java
                    } else {
                        artifact bundleReleaseAar
                    }
                    artifact sourcesJar

                    pom {
                        name = "Android MVVM library, module $childProject.name"
                        description = "$bintray.pkg.desc"
                        url = "$bintray.pkg.websiteUrl"
                        licenses {
                            license {
                                name = "Apache-2.0"
                                url = 'https://www.apache.org/licenses/LICENSE-2.0'
                            }
                        }
                        developers {
                            developer {
                                id = 'asuslennikov'
                                name = 'Suslennikov Anton'
                                email = 'anton.external@gmail.com'
                            }
                        }
                        scm {
                            connection = "$bintray.pkg.vcsUrl"
                            url = "$bintray.pkg.websiteUrl"
                        }
                        withXml {
                            if (isAndroidProject) {
                                appendDependenciesNodeToPom(it, project, 'implementation')
                            } else {
                                fixProjectModuleDependencies(it)
                            }
                        }
                    }
                }
            }
            repositories {
                maven {
                    name = "MavenCentral"

                    def releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
                    def snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots/"
                    url = currentVersion.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl

                    credentials {
                        username ossUser
                        password ossKey
                    }
                }
            }
        }
        signing {
            useInMemoryPgpKeys(signPrivateKey, signPassphrase)
            sign publishing.publications
        }
    }
}
nexusStaging {
    packageGroup = pomGroupId
    stagingProfileId = "912ea0d90f2f6"
    delayBetweenRetriesInMillis = 5000
    username = ossUser
    password = ossKey
}